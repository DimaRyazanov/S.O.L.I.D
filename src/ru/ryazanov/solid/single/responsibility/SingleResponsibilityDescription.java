package ru.ryazanov.solid.single.responsibility;

import ru.ryazanov.solid.Description;
import ru.ryazanov.solid.single.responsibility.example2.solution.Game;

public class SingleResponsibilityDescription implements Description {
    @Override
    public String principles() {
        String result = "";

        result += "Пример №1 (Active Record)\n";

        result += "Класс Animal описывающее какое-то животное.\n" +
                "Он решает две задачи: 1) Манипулирует свойствами объекта в конструкторе и методе getName. " +
                "2) Работает с хранилишем данных в методе save.\n" +
                "В соответствии с принципом единой ответственности класс должен решать лишь какую-то одну задачу," +
                "а он же решает 2.\nПочему это плохо? Если изменится способ (порядок) работы с хранилищем данных (изменится бд и т.п.)," +
                "то придется вносить измениния во все классы работающих с хранилищем.\n" +
                "Такая архитектура не отличается гибкостью, измение одной подсистемы, затрагивает другие.\n";
        result += "Для решения данной проблемы создадим еще один класс AnimalRepository, задачей которого будет работа только" +
                "с хранилишем, в частности сохрание/получение объекта класса Animal (методы get, save).\n";


        result += "\nПример №2 (Validation)\n";

        result += "В проектах часто встречается проблема валидации данных (электронная почта, сложность пароля, длина никнейма. ";
        result += "Например для класса Game необходима реалицация валидации по стоимости.\nМожно реализовать самым простым способом, с помощью метода isValid(). " +
                "Такой подход является вполне оправданным в данном случае. Код простой, тестированию поддается, дублирования логики нет.\n" +
                "Но теперь наш объект Game начал использоваться в некотором сервисе VipCustomerService, для работы с VIP покупателями наших игр.\n" +
                "При предыдущей реализации нам придется изменять сам класс Game изменив метод isValid(), так как логика будет изменяться, например при добавлении новых сервисов.\n" +
                "Решение: Стало очевидно, что при дальнейшем использовании объекта Game логика валидации его данных будет изменяться и усложняться.\n" +
                "Видимо пора отдать ответственность за валидацию данных Game другому объекту - GameValidator, со своими конкретными реализациями.\n" +
                "Причем надо сделать так, чтобы сам объект Game не зависел от конкретной реализации его валидатора. Например заинжектим валидатор через конструктор.\n" +
                "Имеем объект Game отдельно, а любое количество всяческих валидаторов отдельно. Например используя для VipCustomerService - Game game = new Game(new VipGameValidator()).\n";

        return result;
    }
}
